/**
    @file controller_mission.cpp
    @brief 
    Implementation of the Mission state class.
        
    @Copyright (c) 2019 Samuel Ackermann, Simon Wälti
*/

#include <string>
#include <sstream>
#include <chrono>
#include <iomanip>

#include "json.hpp"
#include "helper.h"
#include "controller.h"
#include "sensors.h"
#include "sensor_def.h"

//-------------------------------------------------------------
// Static funcitions
//-------------------------------------------------------------

static const std::string base64_chars = 
             "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
             "abcdefghijklmnopqrstuvwxyz"
             "0123456789+/";

/* 
   base64 encoding and decoding with C++.

   Version: 1.01.00

   Copyright (C) 2004-2017 René Nyffenegger

   This source code is provided 'as-is', without any express or implied
   warranty. In no event will the author be held liable for any damages
   arising from the use of this software.

   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:

   1. The origin of this source code must not be misrepresented; you must not
      claim that you wrote the original source code. If you use this source code
      in a product, an acknowledgment in the product documentation would be
      appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
      misrepresented as being the original source code.

   3. This notice may not be removed or altered from any source distribution.

   René Nyffenegger rene.nyffenegger@adp-gmbh.ch
*/
std::string base64_encode(const char *bytes_to_encode, unsigned int in_len) {
  std::string ret;
  int i = 0;
  int j = 0;
  unsigned char char_array_3[3];
  unsigned char char_array_4[4];

  while (in_len--) {
    char_array_3[i++] = *(bytes_to_encode++);
    if (i == 3) {
      char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
      char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
      char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
      char_array_4[3] = char_array_3[2] & 0x3f;

      for(i = 0; (i <4) ; i++)
        ret += base64_chars[char_array_4[i]];
      i = 0;
    }
  }

  if (i)
  {
    for(j = i; j < 3; j++)
      char_array_3[j] = '\0';

    char_array_4[0] = ( char_array_3[0] & 0xfc) >> 2;
    char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
    char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);

    for (j = 0; (j < i + 1); j++)
      ret += base64_chars[char_array_4[j]];

    while((i++ < 3))
      ret += '=';

  }
  return ret;
}

/**
    Assignes the sensor data with position and time, the result is store in a json file
    (wp0.json, wp1.json, ...)
    @param wpdata information generated by the vehicle
    @param sensors set of sensors (values and ids)
    @param pictures set of ids, pictures musst be assigned to the way point results in the mobile app, OSDK does not allow access to the filesystem.
*/
static void
writeWpResult(WaypointReachedData* wpdata, std::vector<SensorValue> sensors, std::vector<std::string> pictures) {

    //std::time_t t = std::time(0);
    // std::tm* now = std::localtime(&t);
    const auto now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    std::stringstream dstream;
    // 2009-06-15T13:45:30 
    //dstream << (now->tm_year + 1900) << '-' << (now->tm_mon + 1) << '-' <<  now->tm_mday 
    //    << 'T' << now->tm_hour << ':' << now->tm_min << ':' << now->tm_sec;

    dstream <<  std::put_time(std::gmtime(&now), "%FT%TZ");

    nlohmann::json j;
    nlohmann::json sensor_array = nlohmann::json::array();

    // Sensor values: value is always a string
    for (size_t i = 0; i < sensors.size(); i++) {
        std::string strIndex = std::to_string(i);
        sensor_array.push_back({
            {"id", sensors[i].id},
            {"value", base64_encode(sensors[i].value.c_str() , sensors[i].value.size())}, //{"value", base64_encode(sensors[i].value)},
            {"command_id", sensors[i].command }, // TODO id
        });
    }

    // picture id
    for (size_t i = 0; i < pictures.size(); i++) {
        std::string strIndex = std::to_string(i);
        sensor_array.push_back({
            {"id", 0 },
            {"value", pictures[i] },
            {"command_id", 0 },
        });
    }

    j["sensors"] = sensor_array;
    
    j["x"] = wpdata->longitude * 180/M_PI; 
    j["y"] = wpdata->latitude  * 180/M_PI;
    j["z"] = wpdata->altitude;
    j["date"] = dstream.str();
    j["seq"] = wpdata->index;
    std::string file_path;
    file_path.append(WP_EXPORT_PATH);
    file_path.append("/wp");
    file_path.append(std::to_string(wpdata->index));
    file_path.append(".json");

    std::ofstream ofs(file_path);
    ofs << std::setw(4) << j << std::endl;
}

//-------------------------------------------------------------
// Class Mission 
//-------------------------------------------------------------
void 
MspController::Mission::entry() {

    // Check if mission items are valid (coordinates, actions)
    validateMissionItems(); 
    missionActive       = false;
    userCommandPaused   = false;
}

void 
MspController::Mission::exit() {
    missionActive       = false;
    userCommandPaused   = false;
}

// Starts a way point mission, state transfer to idle on error
EResult 
MspController::Mission::missionStart() {

    spdlog::info("MspController::Mission::missionStart");
    EResult ret = EResult::MSP_FAILED;
    currenindex = 0;
    
    // Upload mission data
    ret = context->setVehicleCommand(EVehicleCmd::MSP_CMD_UPLOAD_WAY_POINTS);
    if (ret != EResult::MSP_SUCCESS){
        context->setState(&context->stateIdle);
        return ret;
    }

    // Start mission
    ret = context->setVehicleCommand(EVehicleCmd::MSP_CMD_MISSION_START);
    if (ret != EResult::MSP_SUCCESS){
        context->setState(&context->stateIdle);
        return ret;
    }

    missionActive = true;
    return ret;
}

// Pauses/resumes a way point mission, state transfer to idle on error
EResult 
MspController::Mission::missionPauseContinue() {
    spdlog::info("MspController::Mission::missionPauseContinue");
    EResult ret = EResult::MSP_FAILED;

    if (missionActive) {
        userCommandPaused = true; // exit mission state if vehicle notifies paused
        ret = context->setVehicleCommand(EVehicleCmd::MSP_CMD_MISSION_PAUSE);
    }
    else {
        missionActive = true;
        ret = context->setVehicleCommand(EVehicleCmd::MSP_CMD_MISSION_RESUME);
    }    

    return ret;
}

//------------------------------------------------------------- 
// Command and notification interface
//-------------------------------------------------------------
EResult 
MspController::Mission::setCommand(uint16_t command, mavlink_command_long_t cmd){
    EResult res = EResult::MSP_FAILED;
    switch (command)
    {
    case MAV_CMD_MISSION_START:
        res = missionStart();
        break;
    case MAV_CMD_DO_PAUSE_CONTINUE:
        res = missionPauseContinue();
        break;
    default:
        spdlog::warn("MspController::Mission::setCommand, command not available");
        res =  EResult::MSP_INVALID;
        break;
    }
    return res;
}

/**
    Is called when a way point is reached.
    This function manages the logic for executing actions and next waypoints, 
    if the number of way point is reached, a state transfer to idle is performed.
*/
void 
MspController::Mission::vehicleNotification(EVehicleNotification notification, VehicleData data) {

    switch (notification)
    {
    case EVehicleNotification::MSP_VHC_WAY_POINT_REACHED:
        handleWpReached(data);
        break;  
    case EVehicleNotification::MSP_VHC_MISSION_STOPPED:
        context->mavlink->setCmdResult(EResult::MSP_SUCCESS);
        context->setState(&context->stateIdle);
        break;
    case EVehicleNotification::MSP_VHC_MISSION_PAUSED:
        context->mavlink->setCmdResult(EResult::MSP_SUCCESS);
        if (userCommandPaused) {
            context->setState(&context->stateIdle);
        }
        break;
    case EVehicleNotification::MSP_VHC_MISSION_RESUMED:
        context->mavlink->setCmdResult(EResult::MSP_SUCCESS);
        break;
    default:
        break;
    }
}

//-------------------------------------------------------------
// Mission helpers
//-------------------------------------------------------------

/**
    Performs all action of the current way point. 
*/
void 
MspController::Mission::handleWpReached(VehicleData data) {
    EResult ret = EResult::MSP_FAILED;

    // Handle wpreached data
    WaypointReachedData* wpdata = static_cast<WaypointReachedData*>(data);  
    if (wpdata) {
        spdlog::debug("MspController::Mission::handleWpReached(" + std::to_string(wpdata->index) + ")");
        
        // get current BehaviorItem and execute assigned waypoint actions
        currenindex = wpdata->index;
        mavlink_mission_item_t* item = context->getMissionBehaviorItem(wpdata->index);
        if (item) {

            // check for autocontinue 
            // false: pause mission -> resume mission after actions completed
            // true: execute waypoint actions while mission continues
            if(!item->autocontinue){
                // Pause mission
                spdlog::debug("MspController::Mission::handleWpReached, mission pause");
                context->setVehicleCommand(EVehicleCmd::MSP_CMD_MISSION_PAUSE);
            }

            // Send mission item reached mavlink messsage
            sendMissionItemReached(wpdata->index);

            // Execute waypoint action and stor data to json file
            executeAction(wpdata);

            if (wpdata->index + 1 < context->getMissionItemCount()) {
                // resume mission
                ret = context->setVehicleCommand(EVehicleCmd::MSP_CMD_MISSION_RESUME);
                if (ret != EResult::MSP_SUCCESS && ret != EResult::MSP_PROGRESS){
                    spdlog::debug("MspController::Mission::handleWpReached, mission resume");
                    context->setState(&context->stateIdle);
                    return;
                }
            }
            else {
                // goto origin if the max number of waypoints is reached
                currenindex = -1;
                sendMissionItemReached(-1);
                context->setVehicleCommand(EVehicleCmd::MSP_CMD_RETURN_TO_ORIGIN);
                context->setState(&context->stateIdle);
            }
        }
        else {
            // goto origin if no mission item for the current waypoint is found
            currenindex = -1;
            sendMissionItemReached(-1);
            context->setVehicleCommand(EVehicleCmd::MSP_CMD_RETURN_TO_ORIGIN);
            context->setState(&context->stateIdle);
        }
    }
}

// Performs all action of the current way point.
void 
MspController::Mission::executeAction(WaypointReachedData* wpdata) {
    
    std::vector<mavlink_mission_item_t>* items = context->getMissionItem(wpdata->index);
    if (items) {
        std::vector<SensorValue> sensors;
        std::vector<std::string> pictures;

        // execute all waypoint actions
        for (size_t i = 0; i < items->size(); i++) {
            mavlink_mission_item_t item = (*items)[i];
            SensorValue value;
            switch (item.command)
            {
            case MAV_CMD_USER_2:
                // read sensor values 
                value = MspSensors::getInstance()->getSensorValue((int)item.param1);
                value.command = item.param2; // command for Action mapping in backend
                sensors.push_back(value);
                break;
            case MAV_CMD_IMAGE_START_CAPTURE:

                // take a picture (SDCard filesystem can not be accessed within the OSDK context, 
                // so the assigement picture-waypoint is only in the MSDK possible (media manager))
                context->setVehicleCommand(EVehicleCmd::MSP_CMD_TAKE_PICTURE, &item, 0);
                pictures.push_back(std::to_string(item.command));
                break;
            default:
                break;
            }
        }             
        writeWpResult(wpdata, sensors, pictures);            
    } 
}

// Sends a mission item reached mavlink message
void 
MspController::Mission::sendMissionItemReached(int seq) {
    
    Mavlink* mavlink = context->mavlink;

    mavlink_mission_item_reached_t item;
    item.seq = seq;
    mavlink_msg_mission_item_reached_send_struct(mavlink->getChannel(), &item);

    // Send current mission item
    mavlink_mission_current_t wpc;
    wpc.seq = seq;
    mavlink_msg_mission_current_send_struct(mavlink->getChannel(), &wpc);
}

/**
    Validates all mission items.
    (this function is not used due the fact, dji performs already a validation itself)
*/
void 
MspController::Mission::validateMissionItems() {
    
    // TODO validate coordinates (GEO fence) 
    // Currently done by DJI vehicle itselfe!!!
    /*for (int i = 0; i < context->getMissionItemCount(); i++)
    {
        mavlink_mission_item_t* item = context->getMissionBehaviorItem(i);
    }*/

    /*if (false) {
        context->setState(&context->stateIdle);
    }*/
}

